from hippynn.experiment import assemble_for_training

from mace.calculators import mace_off
from hippynn import settings


# This file creates a model with randomized weights with a specified number of sensitivities (nu),
# number of features (b), and a specified l_max and n_max. It also allows you to decide which optimizations
# you would like to implement (polynomial invariants, tensor envsum forward pass, or tensor envsum backward pass).
# It returns the model and the db_info. The models created by this file are not intended for actual training. 
# Rather, they are intended to be used when testing the evaluation time.

# This function builds the force, energy, and species nodes from a dictionary of network parameters.
def build_nodes(network_params, atomization_consistent):
    from hippynn.graphs import inputs, networks, targets, physics

    species = inputs.SpeciesNode(db_name="Z")
    positions = inputs.PositionsNode(db_name="R")

    network = networks.HipHopnn("hipnn_model", (species, positions), module_kwargs=network_params)

    if not atomization_consistent:
        henergy = targets.HEnergyNode("HEnergy", network)
    else:
        henergy = targets.AtomizationEnergyNode("HEnergy", network)

    force = physics.GradientNode("forces", (henergy, positions), sign=-1)

    return henergy, force, species

# This function builds the loss function that would be used during training.
# Even though the models generated by this file are not meant for training,
# to my knowlege, I need to generate a loss function in order to create a model
# using the normal methods implemented in hippynn. It is possible that there is some
# way to generate the model without generating a loss function. This code was copied
# and pasted from my mace.py wrapper.
def make_loss(henergy, force, species, force_percent):
    """
    Build the loss graph for energy and force error.
    """
    from hippynn.graphs.nodes.loss import MSELoss, MAELoss, Rsq, Mean
    from hippynn.graphs import physics

    E_pred_per_atom = physics.PerAtom("E/atomPred",(henergy.mol_energy.pred,species.true))
    E_true_per_atom = physics.PerAtom("E/atomTrue",(henergy.mol_energy.true,species.true))

    losses = {
        "T-RMSE": MSELoss.of_node(henergy) ** (1 / 2),
        "T-RMSE/atom": MSELoss(E_pred_per_atom, E_true_per_atom) ** (1 / 2),
        "T-MAE": MAELoss.of_node(henergy),
        "T-RSQ": Rsq.of_node(henergy),
        "T-Hier": Mean.of_node(henergy.hierarchicality),
    }

    force_losses = {
        "F-RMSE": MSELoss.of_node(force) ** (1 / 2),
        "F-MAE": MAELoss.of_node(force),
        "F-RSQ": Rsq.of_node(force),
    }

    losses["EnergyTotal"] = losses["T-RMSE"] + losses["T-MAE"]
    losses["LossTotal"] = losses["EnergyTotal"] + losses["T-Hier"]
    if force_percent > 0:
        losses.update(force_losses)
        losses["ForceTotal"] = losses["F-RMSE"] + losses["F-MAE"]
        losses["LossTotal"] = 2*( (1 - force_percent) * losses["LossTotal"] + force_percent * losses["ForceTotal"] )

    return losses

# This if the function that you call to actually make the models.
# here nu, b, l_max, and n_max specify the model size. invars_poly.
# invars_poly, env_tensor, and env_tensor_gradient are bools that can be used to specify
# which optimizations you would like to include (respectively, using polynomial invariants),
# using the fused tensor envsum for the forward pass, and using the fused tensor envsum for
# the backward pass. Note that you currently cannot have env_tensor = True but env_tensor_gradient = False.
# However, the current implementation does support env_tensor = False but env_tensor_gradient = True.
def make_model(nu, b, l_max, n_max, invars_poly, env_tensor, env_tensor_gradient):
    if invars_poly:
        settings.USE_POLYNOMIAL_INVARIANTS = True
    else:
        settings.USE_POLYNOMIAL_INVARIANTS = False

    if env_tensor_gradient:
        settings.USE_TENSOR_MESSAGE_PASSING = True
    else:
        settings.USE_TENSOR_MESSAGE_PASSING = False

    if env_tensor:
        settings.TENSOR_MESSAGE_PASSING_GRAD_ONLY = False
    else:
        settings.TENSOR_MESSAGE_PASSING_GRAD_ONLY = True

    network_parameters = {
        "possible_species": [0,1,6,7,8,9,15,16,17,35,53],
        "n_features": b,
        "n_sensitivities": nu,
        "dist_soft_min": 0.55,
        "dist_soft_max": 5.5,
        "dist_hard_max": 6.5,
        "n_interaction_layers": 2,
        "n_atom_layers": 3,
        "l_max": l_max,
        "n_max": n_max,
    }

    henergy, force, species = build_nodes(network_parameters, False)
    henergy.mol_energy.db_name = "T"
    force.db_name = "F"
    losses = make_loss(henergy, force, species, 0.9)
    train_loss = losses["LossTotal"]
    training_modules, db_info = assemble_for_training(train_loss, losses)
    return training_modules.model, db_info